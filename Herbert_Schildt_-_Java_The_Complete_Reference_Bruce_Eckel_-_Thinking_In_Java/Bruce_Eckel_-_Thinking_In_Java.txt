Preface   
I originally approached Java as �just another programming language,� which in many senses it is.  
But as time passed and I studied it more deeply, I began to see that the fundamental intent of this language was different from other languages I had seen up to that point.  
Programming is about managing complexity: the complexity of the problem you want to solve, laid upon the complexity of the machine in which it is solved. Because of this complexity, most of our programming projects fail. And yet, of all the programming languages of which I am aware, almost none have gone all out and decided that their main design goal would be to conquer the complexity of developing and maintaining programs.1 Of course, many language design decisions were made with complexity in mind, but at some point there were always other issues that were considered essential to be added into the mix. Inevitably, those other issues are what cause programmers to eventually �hit the wall� with that language. For example, C++ had to be backwards-compatible with C (to allow easy migration for C programmers), as well as efficient. Those are both very useful goals and account for much of the success of C++, but they also expose extra complexity that prevents some projects from being finished (certainly, you can blame programmers and management, but if a language can help by catching your mistakes, why shouldn�t it?). As another example, Visual BASIC (VB) was tied to BASIC, which wasn�t really designed to be an extensible language, so all the extensions piled upon VB have produced some truly unmaintainable syntax. Perl is backwards-compatible with awk, sed, grep, and other Unix tools it was meant to replace, and as a result it is often accused of producing �write-only code� (that is, after a while you can�t read it). On the other hand, C++, VB, Perl, and other languages like Smalltalk had some of their design efforts focused on the issue of complexity and as a result are remarkably successful in solving certain types of problems.  
What has impressed me most as I have come to understand Java is that somewhere in the mix of Sun�s design objectives, it seems that there was a goal of reducing complexity for the programmer. As if to say, �We care about reducing the time and difficulty of producing robust code.� In the early days, this goal resulted in code that didn�t run very fast (although this has improved over time), but it has indeed produced amazing reductions in development time�half or less of the time that it takes to create an equivalent C++ program. This result alone can save incredible amounts of time and money, but Java doesn�t stop there. It goes on to wrap many of the complex tasks that have become important, such as multithreading and network programming, in language features or libraries that can at times make those tasks easy. And finally, it tackles some really big complexity problems: cross-platform programs, dynamic code changes, and even security, each of which can fit on your complexity spectrum anywhere from �impediment� to �show-stopper.� So despite the performance problems that we�ve seen, the promise of Java is tremendous: It can make us significantly more productive programmers.  
In all ways�creating the programs, working in teams, building user interfaces to communicate with the user, running the programs on different types of machines, and easily writing programs that communicate across the Internet�Java increases the communication bandwidth between people.  
I think that the results of the communication revolution may not be seen from the effects of moving large quantities of bits around. We shall see the true revolution because we will all communicate with each other more easily: one-on-one, but also in groups and as a planet. 
1 However, I believe that the Python language comes closest to doing exactly that. See www.Python.org. 
I�ve heard it suggested that the next revolution is the formation of a kind of global mind that results from enough people and enough interconnectedness. Java may or may not be the tool that foments that revolution, but at least the possibility has made me feel like I�m doing something meaningful by attempting to teach the language.  Java SE5 and SE6  
This edition of the book benefits greatly from the improvements made to the Java language in what Sun originally called JDK 1.5, and then later changed to JDK5 or J2SE5, then finally they dropped the outdated �2� and changed it to Java SE5. Many of the Java SE5 language changes were designed to improve the experience of the programmer. As you shall see, the Java language designers did not completely succeed at this task, but in general they made large steps in the right direction.  
One of the important goals of this edition is to completely absorb the improvements of Java SE5/6, and to introduce and use them throughout this book. This means that this edition takes the somewhat bold step of being �Java SE5/6-only,� and much of the code in the book will not compile with earlier versions of Java; the build system will complain and stop if you try. However, I think the benefits are worth the risk.  
If you are somehow fettered to earlier versions of Java, I have covered the bases by providing free downloads of previous editions of this book via www.MindView.net. For various reasons, I have decided not to provide the current edition of the book in free electronic form, but only the prior editions.  Java SE6  
This book was a monumental, time-consuming project, and before it was published, Java SE6 (code-named mustang) appeared in beta form. Although there were a few minor changes in Java SE6 that improved some of the examples in the book, for the most part the focus of Java SE6 did not affect the content of this book; the features were primarily speed improvements and library features that were outside the purview of this text.  
The code in this book was successfully tested with a release candidate of Java SE6, so I do not expect any changes that will affect the content of this book. If there are any important changes by the time Java SE6 is officially released, these will be reflected in the book�s source code, which is downloadable from www.MindView.net.  
The cover indicates that this book is for �Java SE5/6,� which means �written for Java SE5 and the very significant changes that version introduced into the language, but is equally applicable to Java SE6.�  The 4th edition  
The satisfaction of doing a new edition of a book is in getting things �right,� according to what I have learned since the last edition came out. Often these insights are in the nature of the saying �A learning experience is what you get when you don�t get what you want,� and my opportunity is to fix something embarrassing or simply tedious. Just as often, creating the next edition produces fascinating new ideas, and the embarrassment is far outweighed by the delight of discovery and the ability to express ideas in a better form than what I have previously achieved.  
There is also the challenge that whispers in the back of my brain, that of making the book something that owners of previous editions will want to buy. This presses me to improve, 
2 Thinking in Java Bruce Eckel 
rewrite and reorganize everything that I can, to make the book a new and valuable experience for dedicated readers.  Changes  
The CD-ROM that has traditionally been packaged as part of this book is not part of this edition. The essential part of that CD, the Thinking in C multimedia seminar (created for MindView by Chuck Allison), is now available as a downloadable Flash presentation. The goal of that seminar is to prepare those who are not familiar enough with C syntax to understand the material presented in this book. Although two of the chapters in this book give decent introductory syntax coverage, they may not be enough for people without an adequate background, and Thinking in C is intended to help those people get to the necessary level.  
The Concurrency chapter (formerly called �Multithreading�) has been completely rewritten to match the major changes in the Java SE5 concurrency libraries, but it still gives you a basic foundation in the core ideas of concurrency. Without that core, it�s hard to understand more complex issues of threading. I spent many months working on this, immersed in that netherworld called �concurrency,� and in the end the chapter is something that not only provides a basic foundation but also ventures into more advanced territory.  
There is a new chapter on every significant new Java SE5 language feature, and the other new features have been woven into modifications made to the existing material. Because of my continuing study of design patterns, more patterns have been introduced throughout the book as well.  

The book has undergone significant reorganization. Much of this has come from the teaching process together with a realization that, perhaps, my perception of what a �chapter� was could stand some rethought. I have tended towards an unconsidered belief that a topic had to be �big enough� to justify being a chapter. But especially while teaching design patterns, I find that seminar attendees do best if I introduce a single pattern and then we immediately do an exercise, even if it means I only speak for a brief time (I discovered that this pace was also more enjoyable for me as a teacher). So in this version of the book I�ve tried to break chapters up by topic, and not worry about the resulting length of the chapters. I think it has been an improvement.  
I have also come to realize the importance of code testing. Without a built-in ConnectInternet.test framework with tests that are run every time you do a build of your system, you have no way of knowing if your code is reliable or not. To accomplish this in the book, I created a ConnectInternet.test framework to display and validate the output of each program. (The framework was written in Python; you can find it in the downloadable code for this book at www.MindView.net.) Testing in general is covered in the supplement you will find at http://MindView.net/Books/BetterJava, which introduces what I now believe are fundamental skills that all programmers should have in their basic toolkit.
In addition, I�ve gone over every single example in the book and asked myself, �Why did I do it this way?� In most cases I have done some modification and improvement, both to make the examples more consistent within themselves and also to demonstrate what I consider to be best practices in Java coding (at least, within the limitations of an introductory text). Many of the existing examples have had very significant redesign and reimplementation. Examples that no longer made sense to me were removed, and new examples have been added.  
Readers have made many, many wonderful comments about the first three editions of this book, which has naturally been very pleasant for me. However, every now and then, someone will have complaints, and for some reason one complaint that comes up periodically is �The book is too big.� In my mind it is faint damnation indeed if �too many pages� is your only 
Preface 3�
gripe. (One is reminded of the Emperor of Austria�s complaint about Mozart�s work: �Too many notes!� Not that I am in any way trying to compare myself to Mozart.) In addition, I can only assume that such a complaint comes from someone who is yet to be acquainted with the vastness of the Java language itself and has not seen the rest of the books on the subject. Despite this, one of the things I have attempted to do in this edition is trim out the portions that have become obsolete, or at least nonessential. In general, I�ve tried to go over everything, remove what is no longer necessary, include changes, and improve everything I could. I feel comfortable removing portions because the original material remains on the Web site (www.MindView.net), in the form of the freely downloadable 1st through 3rd editions of the book, and in the downloadable supplements for this book.  
For those of you who still can�t stand the size of the book, I do apologize. Believe it or not, I have worked hard to keep the size down.  Note on the cover design  
The cover of Thinking in Java is inspired by the American Arts & Crafts Movement that began near the turn of the century and reached its zenith between 1900 and 1920. It began in England as a reaction to both the machine production of the Industrial Revolution and the highly ornamental style of the Victorian era. Arts & Crafts emphasized spare design, the forms of nature as seen in the art nouveau movement, hand-crafting, and the importance of the individual craftsperson, and yet it did not eschew the use of modern tools. There are many echoes with the situation we have today: the turn of the century, the evolution from the raw beginnings of the computer revolution to something more refined and meaningful, and the emphasis on software craftsmanship rather than just manufacturing code.  I see Java in this same way: as an attempt to elevate the programmer away from an operating system mechanic and toward being a �software craftsman.�  
Both the author and the book/cover designer (who have been friends since childhood) find inspiration in this movement, and both own furniture, lamps, and other pieces that are either original or inspired by this period.  
The other theme in this cover suggests a collection box that a naturalist might use to display the insect specimens that he or she has preserved. These insects are objects that are placed within the box objects. The box objects are themselves placed within the �cover object,� which illustrates the fundamental concept of aggregation in object-oriented programming. Of course, a programmer cannot help but make the association with �bugs,� and here the bugs have been captured and presumably killed in a specimen jar, and finally confined within a small display box, as if to imply Java�s ability to find, display, and subdue bugs (which is truly one of its most powerful attributes).  
In this edition, I created the watercolor painting that you see as the cover background.  Acknowledgements  
First, thanks to associates who have worked with me to give seminars, provide consulting, and develop teaching projects: Dave Bartlett, Bill Venners, Chuck Allison, Jeremy Meyer, and Jamie King. I appreciate your patience as I continue to try to develop the best model for independent folks like us to work together.  
Recently, no doubt because of the Internet, I have become associated with a surprisingly large number of people who assist me in my endeavors, usually working from their own home offices. In the past, I would have had to pay for a pretty big office space to accommodate all these folks, but because of the Net, FedEx, and the telephone, I�m able to benefit from their help without the extra costs. In my attempts to learn to �play well with 
4 Thinking in Java Bruce Eckel 
others,� you have all been very helpful, and I hope to continue learning how to make my own work better through the efforts of others. Paula Steuer has been invaluable in taking over my haphazard business practices and making them sane (thanks for prodding me when I don�t want to do something, Paula). Jonathan Wilcox, Esq., has sifted through my corporate structure and turned over every possible rock that might hide scorpions, and frog-marched us through the process of putting everything straight, legally. Thanks for your care and persistence. Sharlynn Cobaugh has made herself an expert in sound processing and an essential part of creating the multimedia training experiences, as well as tackling other problems. Thanks for your perseverance when faced with intractable computer problems. The folks at Amaio in Prague have helped me out with several projects. Daniel Will-Harris was the original work-by-Internet inspiration, and he is of course fundamental to all my graphic design solutions.  
Over the years, through his conferences and workshops, Gerald Weinberg has become my unofficial coach and mentor, for which I thank him.  
Ervin Varga was exceptionally helpful with technical corrections on the 4th edition�although other people helped on various chapters and examples, Ervin was my primary technical reviewer for the book, and he also took on the task of rewriting the solution guide for the 4th edition. Ervin found errors and made improvements to the book that were invaluable additions to this text. His thoroughness and attention to detail are amazing, and he�s far and away the best technical reader I�ve ever had. Thanks, Ervin.  
My weblog on Bill Venners� www.Artima.com has been a source of assistance when I�ve needed to bounce ideas around. Thanks to the readers that have helped me clarify concepts by submitting comments, including James Watson, Howard Lovatt, Michael Barker, and others, in particular those who helped with generics.  
Thanks to Mark Welsh for his continuing assistance.  
Evan Cofsky continues to be very supportive by knowing off the top of his head all the arcane details of setting up and maintaining Linux-based Web servers, and keeping the MindView server tuned and secure.  
A special thanks to my new friend, coffee, who generated nearly boundless enthusiasm for this project. Camp4 Coffee in Crested Butte, Colorado, has become the standard hangout when people have come up to take MindView seminars, and during seminar breaks it is the best catering I�ve ever had. Thanks to my buddy Al Smith for creating it and making it such a great place, and for being such an interesting and entertaining part of the Crested Butte experience. And to all the Camp4 barristas who so cheerfully dole out beverages.  
Thanks to the folks at Prentice Hall for continuing to give me what I want, putting up with all my special requirements, and for going out of their way to make things run smoothly for me.  
Certain tools have proved invaluable during my development process and I am very grateful to the creators every time I use these. Cygwin (www.cygwin.com) has solved innumerable problems for me that Windows can�t/won�t and I become more attached to it each day (if I only had this 15 years ago when my brain was still hard-wired with Gnu Emacs). IBM�s Eclipse (www.eclipse.org) is a truly wonderful contribution to the development community, and I expect  
to see great things from it as it continues to evolve (how did IBM become hip? I must have missed a memo). JetBrains IntelliJ Idea continues to forge creative new paths in development tools.  
I began using Enterprise Architect from Sparxsystems on this book, and it has rapidly become my UML tool of choice. Marco Hunsicker�s Jalopy code formatter (www.triemax.com) came in handy on numerous occasions, and Marco was very helpful in 
Preface 5� 
configuring it to my particular needs. I�ve also found Slava Pestov�s JEdit and plug-ins to be helpful at times (www.jedit.org) and it�s quite a reasonable beginner�s editor for seminars.  
And of course, if I don�t say it enough everywhere else, I use Python (www.Python.org) constantly to solve problems, the brainchild of my buddy Guido Van Rossum and the gang of goofy geniuses with whom I spent a few great days sprinting (Tim Peters, I�ve now framed that mouse you borrowed, officially named the �TimBotMouse�). You guys need to find healthier places to eat lunch. (Also, thanks to the entire Python community, an amazing bunch of people.)  
Lots of people sent in corrections and I am indebted to them all, but particular thanks go to (for the 1st edition): Kevin Raulerson (found tons of great bugs), Bob Resendes (simply incredible), John Pinto, Joe Dante, Joe Sharp (all three were fabulous), David Combs (many grammar and clarification corrections), Dr. Robert Stephenson, John Cook, Franklin Chen, Zev Griner, David Karr, Leander A. Stroschein, Steve Clark, Charles A. Lee, Austin Maher, Dennis P. Roth, Roque Oliveira, Douglas Dunn, Dejan Ristic, Neil Galarneau, David B. Malkovsky, Steve Wilkinson, and a host of others. Prof. Ir. Marc Meurrens put in a great deal of effort to publicize and make the electronic version of the 1st edition of the book available in Europe.  
Thanks to those who helped me rewrite the examples to use the Swing library (for the 2nd edition), and for other assistance: Jon Shvarts, Thomas Kirsch, Rahim Adatia, Rajesh Jain, Ravi Manthena, Banu Rajamani, Jens Brandt, Nitin Shivaram, Malcolm Davis, and everyone who expressed support.  
In the 4th edition, Chris Grindstaff was very helpful during the development of the SWT section, and Sean Neville wrote the first draft of the Flex section for me.  
Kraig Brockschmidt and Gen Kiyooka have been some of the smart technical people in my life who have become friends and have also been both influential and unusual in that they do yoga and practice other forms of spiritual enhancement, which I find quite inspirational and instructional.  
It�s not that much of a surprise to me that understanding Delphi helped me understand Java, since there are many concepts and language design decisions in common. My Delphi friends provided assistance by helping me gain insight into that marvelous programming environment. They are Marco Cantu (another Italian�perhaps being steeped in Latin gives one aptitude for programming languages?), Neil Rubenking (who used to do the yoga/vegetarian/Zen thing until he discovered computers), and of course Zack Urlocker (the original Delphi product manager), a long-time pal whom I�ve traveled the world with. We�re all indebted to the brilliance of Anders Hejlsberg, who continues to toil away at C# (which, as you�ll learn in this book, was a major inspiration for Java SE5).  
My friend Richard Hale Shaw�s insights and support have been very helpful (and Kim�s, too). Richard and I spent many months giving seminars together and trying to work out the perfect learning experience for the attendees.  
The book design, cover design, and cover photo were created by my friend Daniel WillHarris, noted author and designer (www.Will-Harris.com), who used to play with rub-on letters in  
junior high school while he awaited the invention of computers and desktop publishing, and complained of me mumbling over my algebra problems. However, I produced the cameraready pages myself, so the typesetting errors are mine. Microsoft� Word XP for Windows was used to write the book and to create camera-ready pages in Adobe Acrobat; the book was created directly from the Acrobat PDF files. As a tribute to the electronic age, I happened to be overseas when I produced the final versions of the 1st and 2nd editions of the book�the 1st edition was sent from Cape Town, South Africa, and the 2nd edition was posted from Prague. 
6 Thinking in Java Bruce Eckel 
Preface 7�
The 3rd and 4th came from Crested Butte, Colorado. The body typeface is Georgia and the headlines are in Verdana. The cover typeface is ITC Rennie Mackintosh.  
A special thanks to all my teachers and all my students (who are my teachers as well).  
Molly the cat often sat in my lap while I worked on this edition, and thus offered her own kind of warm, furry support.  
The supporting cast of friends includes, but is not limited to: Patty Gast (Masseuse extraordinaire), Andrew Binstock, Steve Sinofsky, JD Hildebrandt, Tom Keffer, Brian McElhinney, Brinkley Barr, Bill Gates at Midnight Engineering Magazine, Larry Constantine and Lucy Lockwood, Gene Wang, Dave Mayer, David Intersimone, Chris and Laura Strand, the Almquists, Brad Jerbic, Marilyn Cvitanic, Mark Mabry, the Robbins families, the Moelter families (and the McMillans), Michael Wilk, Dave Stoner, the Cranstons, Larry Fogg, Mike Sequeira, Gary Entsminger, Kevin and Sonda Donovan, Joe Lordi, Dave and Brenda Bartlett, Patti Gast, Blake, Annette & Jade, the Rentschlers, the Sudeks, Dick, Patty, and Lee Eckel, Lynn and Todd, and their families. And of course, Mom and Dad.

Introduction  
�He gave man speech, and speech created thought, Which is the measure of the Universe��Prometheus Unbound, Shelley  
Human beings ... are very much at the mercy of the particular language which has become the medium of expression for their society. It is quite an illusion to imagine that one adjusts to reality essentially without the use of language and that language is merely an incidental means of solving specific problems of communication and reflection. The fact of the matter is that the �real world� is to a large extent unconsciously built up on the language habits of the group.  
The Status of Linguistics as a Science, 1929, Edward Sapir  
Like any human language, Java provides a way to express concepts. If successful, this medium of expression will be significantly easier and more flexible than the alternatives as problems grow larger and more complex.  
You can�t look at Java as just a collection of features�some of the features make no sense in isolation. You can use the sum of the parts only if you are thinking about design, not simply coding. And to understand Java in this way, you must understand the problems with the language and with programming in general. This book discusses programming problems, why they are problems, and the approach Java has taken to solve them. Thus, the set of features that I explain in each chapter are based on the way I see a particular type of problem being solved with the language. In this way I hope to move you, a little at a time, to the point where the Java mindset becomes your native tongue.  
Throughout, I�ll be taking the attitude that you want to build a model in your head that allows you to develop a deep understanding of the language; if you encounter a puzzle, you�ll feed it to your model and deduce the answer.  Prerequisites  
This book assumes that you have some programming familiarity: You understand that a program is a collection of statements, the idea of a subroutine/function/macro, control statements such as �if� and looping constructs such as �while,� etc. However, you might have learned this in many places, such as programming with a macro language or working with a tool like Perl. As long as you�ve programmed to the point where you feel comfortable with the basic ideas of programming, you�ll be able to work through this book. Of course, the book will be easier for C programmers and more so for C++ programmers, but don�t count yourself out if you�re not experienced with those languages�however, come willing to work hard. Also, the Thinking in C multimedia seminar that you can download from www.MindView.net will bring you up to speed in the fundamentals necessary to learn Java. However, I will be introducing the concepts of object-oriented programming (OOP) and Java�s basic control mechanisms.  
Although references may be made to C and C++ language features, these are not intended to be insider comments, but instead to help all programmers put Java in perspective with those languages, from which, after all, Java is descended. I will attempt to make these references simple and to explain anything that I think a non-C/C++ programmer would not be familiar with.  
�
Learning Java  
At about the same time that my first book, Using C++ (Osborne/McGraw-Hill, 1989), came out, I began teaching that language. Teaching programming ideas has become my profession; I�ve seen nodding heads, blank faces, and puzzled expressions in audiences all over the world since 1987. As I began giving in-house training with smaller groups of people, I discovered something during the exercises. Even those people who were smiling and nodding were confused about many issues. I found out, by creating and chairing the C++ track at the Software Development Conference for a number of years (and later creating and chairing the Java track), that I and other speakers tended to give the typical audience too many topics too quickly. So eventually, through both variety in the audience level and the way that I presented the material, I would end up losing some portion of the audience. Maybe it�s asking too much, but because I am one of those people resistant to traditional lecturing (and for most people, I believe, such resistance results from boredom), I wanted to try to keep everyone up to speed.  
For a time, I was creating a number of different presentations in fairly short order. Thus, I ended up learning by experiment and iteration (a technique that also works well in program design). Eventually, I developed a course using everything I had learned from my teaching experience. My company, MindView, Inc., now gives this as the public and in-house Thinking in Java seminar; this is our main introductory seminar that provides the foundation for our more advanced seminars. You can find details at www.MindView.net. (The introductory seminar is also available as the Hands-On Java CD ROM. Information is available at the same Web site.)  
The feedback that I get from each seminar helps me change and refocus the material until I think it works well as a teaching medium. But this book isn�t just seminar notes; I tried to pack as much information as I could within these pages, and structured it to draw you through into the next subject. More than anything, the book is designed to serve the solitary reader who is struggling with a new programming language.  Goals  
Like my previous book, Thinking in C++, this book was designed with one thing in mind: the way people learn a language. When I think of a chapter in the book, I think in terms of what makes a good lesson during a seminar. Seminar audience feedback helped me understand the difficult parts that needed illumination. In the areas where I got ambitious and included too many features all at once, I came to know�through the process of presenting the material� that if you include a lot of new features, you need to explain them all, and this easily compounds the student�s confusion.  
Each chapter tries to teach a single feature, or a small group of associated features, without relying on concepts that haven�t been introduced yet. That way you can digest each piece in the context of your current knowledge before moving on.  
My goals in this book are to:  
1. Present the material one simple step at a time so that you can easily digest each idea     before moving on. Carefully sequence the presentation of features so that you�re exposed to a topic before you see it in use. Of course, this isn�t always possible; in those situations, a brief introductory description is given. 
 
2. Use examples that are as simple and short as possible. This sometimes prevents me from tackling �real world� problems, but I�ve found that beginners are usually happier when they can understand every detail of an example rather than being impressed by 
10 Thinking in Java Bruce Eckel 
the scope of the problem it solves. Also, there�s a severe limit to the amount of code that can be absorbed in a classroom situation. For this I will no doubt receive criticism for using �toy examples,� but I�m willing to accept that in favor of producing something pedagogically useful.  
 
3. Give you what I think is important for you to understand about the language, rather than everything that I know. I believe there is an information importance hierarchy, and that there are some facts that 95 percent of programmers will never need to know�details that just confuse people and increase their perception of the complexity of the language. To take an example from C, if you memorize the operator precedence table (I never did), you can write clever code. But if you need to think about it, it will also confuse the reader/maintainer of that code. So forget about precedence, and use parentheses when things aren�t clear.  
 
4. Keep each section focused enough so that the lecture time�and the time between exercise periods�is small. Not only does this keep the audience�s minds more active and involved during a hands-on seminar, but it gives the reader a greater sense of accomplishment.  
 
5. Provide you with a solid foundation so that you can understand the issues well enough to move on to more difficult coursework and books.  Teaching from this book  
The original edition of this book evolved from a one-week seminar which was, when Java was in its infancy, enough time to cover the language. As Java grew and continued to encompass more and more features and libraries, I stubbornly tried to teach it all in one week. At one point, a customer asked me to teach �just the fundamentals,� and in doing so I discovered that trying to cram everything into a single week had become painful for both myself and for seminarians. Java was no longer a �simple� language that could be taught in a week.  
That experience and realization drove much of the reorganization of this book, which is now designed to support a two-week seminar or a two-term college course. The introductory portion ends with the Error Handling with Exceptions chapter, but you may also want to supplement this with an introduction to JDBC, Servlets and JSPs. This provides a foundation course, and is the core of the Hands-On Java CD ROM. The remainder of the book comprises an intermediatelevel course, and is the material covered in the Intermediate Thinking in Java CD ROM. Both of these CD ROMs are for sale at www.MindView.net.  
Contact Prentice-Hall at www.prenhallprofessional.com for information about professor support materials for this book.  JDK HTML documentation  
The Java language and libraries from Sun Microsystems (a free download from http://java.sun.com) come with documentation in electronic form, readable using a Web browser. Many books published on Java have duplicated this documentation. So you either already have it or you can download it, and unless necessary, this book will not repeat that documentation, because it�s usually much faster if you find the class descriptions with your Web browser than if you look them up in a book (and the online documentation is probably more upto-date). You�ll simply be referred to �the JDK documentation.� This book will provide extra descriptions of the classes only when it�s necessary to supplement that documentation so you can understand a particular example.  
Introduction 11�
Exercises  
I�ve discovered that simple exercises are exceptionally useful to complete a student�s understanding during a seminar, so you�ll find a set at the end of each chapter.  
Most exercises are designed to be easy enough that they can be finished in a reasonable amount of time in a classroom situation while the instructor observes, making sure that all the students are absorbing the material. Some are more challenging, but none present major challenges.  
Solutions to selected exercises can be found in the electronic document The Thinking in Java Annotated Solution Guide, available for sale from www.MindView.net.  Foundations for Java  
Another bonus with this edition is the free multimedia seminar that you can download from www.MindView.net. This is the Thinking in C seminar that gives you an introduction to the C syntax, operators, and functions that Java syntax is based upon. In previous editions of the book this was in the Foundations for Java CD that was packaged with the book, but now the seminar may be freely downloaded.  
I originally commissioned Chuck Allison to create Thinking in C as a standalone product, but decided to include it with the 2nd edition of Thinking in C++ and 2nd and 3rd editions of Thinking in Java because of the consistent experience of having people come to seminars without an adequate background in basic C syntax. The thinking apparently goes �I�m a smart programmer and I don�t want to learn C, but rather C++ or Java, so I�ll just skip C and go directly to C++/Java.� After arriving at the seminar, it slowly dawns on folks that the prerequisite of understanding C syntax is there for a very good reason.  
Technologies have changed, and it made more sense to rework Thinking in C as a downloadable Flash presentation rather than including it as a CD. By providing this seminar online, I can ensure that everyone can begin with adequate preparation.  
The Thinking in C seminar also allows the book to appeal to a wider audience. Even though the Operators and Controlling Execution chapters do cover the fundamental parts of Java that come from C, the online seminar is a gentler introduction, and assumes even less about the student�s programming background than does the book.  Source code  
All the source code for this book is available as copyrighted freeware, distributed as a single package, by visiting the Web site www.MindView.net. To make sure that you get the most current version, this is the official code distribution site. You may distribute the code in classroom and other educational situations.  
The primary goal of the copyright is to ensure that the source of the code is properly cited, and to prevent you from republishing the code in print media without permission. (As long as the source is cited, using examples from the book in most media is generally not a problem.)  
In each source-code file you will find a reference to the following copyright notice:
Introduction      to Objects  
�We cut nature up, organize it into concepts, and ascribe significances as we do, largely because we are parties to an agreement that holds throughout our speech community and is codified in the patterns of our language � we cannot talk at all except by subscribing to the organization and classification of data which the agreement decrees.� Benjamin Lee Whorf (1897-1941)  
The genesis of the computer revolution was in a machine. The genesis of our programming languages thus tends to look like that machine.  
But computers are not so much machines as they are mind amplification tools (�bicycles for the mind,� as Steve Jobs is fond of saying) and a different kind of expressive medium. As a result, the tools are beginning to look less like machines and more like parts of our minds, and also like other forms of expression such as writing, painting, sculpture, animation, and filmmaking. Object-oriented programming (OOP) is part of this movement toward using the computer as an expressive medium.  
This chapter will introduce you to the basic concepts of OOP, including an overview of development methods. This chapter, and this book, assumes that you have some programming experience, although not necessarily in C. If you think you need more preparation in programming before tackling this book, you should work through the Thinking in C multimedia seminar, downloadable from www.MindView.net.  
This chapter is background and supplementary material. Many people do not feel comfortable wading into object-oriented programming without understanding the big picture first. Thus, there are many concepts that are introduced here to give you a solid overview of OOP. However, other people may not get the big picture concepts until they�ve seen some of the mechanics first; these people may become bogged down and lost without some code to get their hands on. If you�re part of this latter group and are eager to get to the specifics of the language, feel free to jump past this chapter�skipping it at this point will not prevent you from writing programs or learning the language. However, you will want to come back here eventually to fill in your knowledge so you can understand why objects are important and how to design with them.  The progress of abstraction 
All programming languages provide abstractions. It can be argued that the complexity of the problems you�re able to solve is directly related to the kind and quality of abstraction. By �kind� I mean, �What is it that you are abstracting?� Assembly language is a small abstraction of the underlying machine. Many so-called �imperative� languages that followed (such as FORTRAN, BASIC, and C) were abstractions of assembly language. These languages are big improvements over assembly language, but their primary abstraction still requires you to think in terms of the structure of the computer rather than the structure of the problem you are trying to solve. The programmer must establish the association between the machine model (in the �solution space,� which is the place where you�re implementing that solution, such as a computer) and the model of the problem that is actually being solved (in the 
�
16 Thinking in Java Bruce Eckel 
�problem space,� which is the place where the problem exists, such as a business). The effort required to perform this mapping, and the fact that it is extrinsic to the programming language, produces programs that are difficult to write and expensive to maintain, and as a side effect created the entire �programming methods� industry.  
The alternative to modeling the machine is to model the problem you�re trying to solve. Early languages such as LISP and APL chose particular views of the world (�All problems are ultimately lists� or �All problems are algorithmic,� respectively). Prolog casts all problems into chains of decisions. Languages have been created for constraint-based programming and for programming exclusively by manipulating graphical symbols. (The latter proved to be too restrictive.) Each of these approaches may be a good solution to the particular class of problem they�re designed to solve, but when you step outside of that domain they become awkward.  
The object-oriented approach goes a step further by providing tools for the programmer to represent elements in the problem space. This representation is general enough that the programmer is not constrained to any particular type of problem. We refer to the elements in the problem space and their representations in the solution space as �objects.� (You will also need other objects that don�t have problem-space analogs.) The idea is that the program is allowed to adapt itself to the lingo of the problem by adding new types of objects, so when you read the code describing the solution, you�re reading words that also express the problem. This is a more flexible and powerful language abstraction than what we�ve had before.1 Thus, OOP allows you to describe the problem in terms of the problem, rather than in terms of the computer where the solution will run. There�s still a connection back to the computer: Each object looks quite a bit like a little computer�it has a state, and it has operations that you can ask it to perform. However, this doesn�t seem like such a bad analogy to objects in the real world�they all have characteristics and behaviors.  
Alan Kay summarized five basic characteristics of Smalltalk, the first successful objectoriented language and one of the languages upon which Java is based. These characteristics represent a pure approach to object-oriented programming:  
1. Everything is an object. Think of an object as a fancy variable; it stores data, but you can �make requests� to that object, asking it to perform operations on itself. In theory, you can take any conceptual component in the problem you�re trying to solve (dogs, buildings, services, etc.) and represent it as an object in your program.  
 
2. A program is a bunch of objects telling each other what to do by sending messages. To make a request of an object, you �send a message� to that object. More concretely, you can think of a message as a request to call a method that belongs to a particular object.  
 
3. Each object has its own memory made up of other objects. Put another way, you create a new kind of object by making a package containing existing objects. Thus, you can build complexity into a program while hiding it behind the simplicity of objects.  
 
4. Every object has a type. Using the parlance, each object is an instance of a class, in which �class� is synonymous with �type.� The most important distinguishing characteristic of a class is �What messages can you send to it?�  
 
5. All objects of a particular type can receive the same messages. This is actually a loaded statement, as you will see later. Because an object of type �circle� is also an object of type �shape,� a circle is guaranteed to accept shape messages. This
1 Some language designers have decided that object-oriented programming by itself is not adequate to easily solve all programming problems, and advocate the combination of various approaches into multiparadigm programming languages. See Multiparadigm Programming in Leda by Timothy Budd (Addison-Wesley, 1995). 
Introduction to Objects 17�
means you can write code that talks to shapes and automatically handle anything that fits the description of a shape. This substitutability is one of the powerful concepts in OOP.  
 
Booch offers an even more succinct description of an object:  
An object has state, behavior and identity.  
This means that an object can have internal data (which gives it state), methods (to produce behavior), and each object can be uniquely distinguished from every other object�to put this in a concrete sense, each object has a unique address in memory.2 An object has an interface  
Aristotle was probably the first to begin a careful study of the concept of type; he spoke of �the class of fishes and the class of birds.� The idea that all objects, while being unique, are also part of a class of objects that have characteristics and behaviors in common was used directly in the first object-oriented language, Simula-67, with its fundamental keyword class that introduces a new type into a program.  
Simula, as its name implies, was created for developing simulations such as the classic �bank teller problem.� In this, you have numerous tellers, customers, accounts, transactions, and units of money�a lot of �objects.� Objects that are identical except for their state during a program�s execution are grouped together into �classes of objects,� and that�s where the keyword class came from. Creating abstract data types (classes) is a fundamental concept in object-oriented programming. Abstract data types work almost exactly like built-in types: You can create variables of a type (called objects or instances in object-oriented parlance) and manipulate those variables (called sending messages or requests; you send a message and the object figures out what to do with it). The members (elements) of each class share some commonality: Every account has a balance, every teller can accept a deposit, etc. At the same time, each member has its own state: Each account has a different balance, each teller has a name. Thus, the tellers, customers, accounts, transactions, etc., can each be represented with a unique entity in the computer program. This entity is the object, and each object belongs to a particular class that defines its characteristics and behaviors.  
So, although what we really do in object-oriented programming is create new data types, virtually all object-oriented programming languages use the �class� keyword. When you see the word �type� think �class� and vice versa.3 
Since a class describes a set of objects that have identical characteristics (data elements) and behaviors (functionality), a class is really a data type because a floating point number, for example, also has a set of characteristics and behaviors. The difference is that a programmer defines a class to fit a problem rather than being forced to use an existing data type that was designed to represent a unit of storage in a machine. You extend the programming language by adding new data types specific to your needs. The programming system welcomes the new classes and gives them all the care and type checking that it gives to built-in types.  
The object-oriented approach is not limited to building simulations. Whether or not you agree that any program is a simulation of the system you�re designing, the use of OOP techniques can easily reduce a large set of problems to a simple solution.  ����������������������������������������������������������� � 2 This is actually a bit restrictive, since objects can conceivably exist in different machines and address spaces, and they can also be stored on disk. In these cases, the identity of the object must be determined by something other than memory address. 
 
3 Some people make a distinction, stating that type determines the interface while class is a particular implementation of that interface.  
Once a class is established, you can make as many objects of that class as you like, and then manipulate those objects as if they are the elements that exist in the problem you are trying to solve. Indeed, one of the challenges of object-oriented programming is to create a one-toone mapping between the elements in the problem space and objects in the solution space.  
But how do you get an object to do useful work for you? There needs to be a way to make a request of the object so that it will do something, such as complete a transaction, draw something on the screen, or turn on a switch. And each object can satisfy only certain requests. The requests you can make of an object are defined by its interface, and the type is what determines the interface. A simple example might be a representation of a light bulb
The interface determines the requests that you can make for a particular object. However, there must be code somewhere to satisfy that request. This, along with the hidden data, comprises the implementation. From a procedural programming standpoint, it�s not that complicated. A type has a method associated with each possible request, and when you make a particular request to an object, that method is called. This process is usually summarized by saying that you �send a message� (make a request) to an object, and the object figures out what to do with that message (it executes code).  
Here, the name of the type/class is Light, the name of this particular Light object is lt, and the requests that you can make of a Light object are to turn it on, turn it off, make it brighter, or make it dimmer. You create a Light object by defining a �reference� (lt) for that object and calling new to request a new object of that type. To send a message to the object, you state the name of the object and connect it to the message request with a period (dot). From the standpoint of the user of a predefined class, that�s pretty much all there is to programming with objects.  
The preceding diagram follows the format of the Unified Modeling Language (UML). Each class is represented by a box, with the type name in the top portion of the box, any data members that you care to describe in the middle portion of the box, and the methods (the functions that belong to this object, which receive any messages you send to that object) in the bottom portion of the box. Often, only the name of the class and the public methods are shown in UML design diagrams, so the middle portion is not shown, as in this case. If you�re interested only in the class name, then the bottom portion doesn�t need to be shown, either.  An object provides services  
While you�re trying to develop or understand a program design, one of the best ways to think about objects is as �service providers.� Your program itself will provide services to the user, and it will accomplish this by using the services offered by other objects. Your goal is to 
18 Thinking in Java Bruce Eckel 
Introduction to Objects 19�
produce (or even better, locate in existing code libraries) a set of objects that provide the ideal services to solve your problem.  
A way to start doing this is to ask, �If I could magically pull them out of a hat, what objects would solve my problem right away?� For example, suppose you are creating a bookkeeping program. You might imagine some objects that contain pre-defined bookkeeping input screens, another set of objects that perform bookkeeping calculations, and an object that handles printing of checks and invoices on all different kinds of printers. Maybe some of these objects already exist, and for the ones that don�t, what would they look like? What services would those objects provide, and what objects would they need to fulfill their obligations? If you keep doing this, you will eventually reach a point where you can say either, �That object seems simple enough to sit down and write� or �I�m sure that object must exist already.� This is a reasonable way to decompose a problem into a set of objects.  
Thinking of an object as a service provider has an additional benefit: It helps to improve the cohesiveness of the object. High cohesion is a fundamental quality of software design: It means that the various aspects of a software component (such as an object, although this could also apply to a method or a library of objects) �fit together� well. One problem people have when designing objects is cramming too much functionality into one object. For example, in your check printing module, you may decide you need an object that knows all about formatting and printing. You�ll probably discover that this is too much for one object, and that what you need is three or more objects. One object might be a catalog of all the possible check layouts, which can be queried for information about how to print a check. One object or set of objects can be a generic printing interface that knows all about different kinds of printers (but nothing about bookkeeping�this one is a candidate for buying rather than writing yourself). And a third object could use the services of the other two to accomplish the task. Thus, each object has a cohesive set of services it offers. In a good object-oriented design, each object does one thing well, but doesn�t try to do too much. This not only allows the discovery of objects that might be purchased (the printer interface object), but it also produces new objects that might be reused somewhere else (the catalog of check layouts).  
Treating objects as service providers is a great simplifying tool. This is useful not only during the design process, but also when someone else is trying to understand your code or reuse an object. If they can see the value of the object based on what service it provides, it makes it much easier to fit it into the design.  The hidden implementation  
It is helpful to break up the playing field into class creators (those who create new data types) and client programmers4 (the class consumers who use the data types in their applications). The goal of the client programmer is to collect a toolbox full of classes to use for rapid application development. The goal of the class creator is to build a class that exposes only what�s necessary to the client programmer and keeps everything else hidden. Why? Because if it�s hidden, the client programmer can�t access it, which means that the class creator can change the hidden portion at will without worrying about the impact on anyone else. The hidden portion usually represents the tender insides of an object that could easily be corrupted by a careless or uninformed client programmer, so hiding the implementation reduces program bugs.  
In any relationship it�s important to have boundaries that are respected by all parties involved. When you create a library, you establish a relationship with the client programmer, who is also a programmer, but one who is putting together an application by using your library, possibly to build a bigger library. If all the members of a class are available to everyone, then the client programmer can do anything with that class and there�s no way to enforce rules. Even though you might really prefer that the client programmer not directly 
4 I�m indebted to my friend Scott Meyers for this term. 
manipulate some of the members of your class, without access control there�s no way to prevent it. Everything�s naked to the world.  
So the first reason for access control is to keep client programmers� hands off portions they shouldn�t touch�parts that are necessary for the internal operation of the data type but not part of the interface that users need in order to solve their particular problems. This is actually a service to client programmers because they can easily see what�s important to them and what they can ignore.  
The second reason for access control is to allow the library designer to change the internal workings of the class without worrying about how it will affect the client programmer. For example, you might implement a particular class in a simple fashion to ease development, and then later discover that you need to rewrite it in order to make it run faster. If the interface and implementation are clearly separated and protected, you can accomplish this easily.  
Java uses three explicit keywords to set the boundaries in a class: public, private, and protected. These access specifiers determine who can use the definitions that follow. public means the following element is available to everyone. The private keyword, on the other hand, means that no one can access that element except you, the creator of the type, inside methods of that type. private is a brick wall between you and the client programmer. Someone who tries to access a private member will get a compile-time error. The protected keyword acts like private, with the exception that an inheriting class has access to protected members, but not private members. Inheritance will be introduced shortly.  
Java also has a �default� access, which comes into play if you don�t use one of the aforementioned specifiers. This is usually called package access because classes can access the members of other classes in the same package (library component), but outside of the package those same members appear to be private.
Reusing the implementation  
Once a class has been created and tested, it should (ideally) represent a useful unit of code. It turns out that this reusability is not nearly so easy to achieve as many would hope; it takes experience and insight to produce a reusable object design. But once you have such a design, it begs to be reused. Code reuse is one of the greatest advantages that object-oriented programming languages provide.  
The simplest way to reuse a class is to just use an object of that class directly, but you can also place an object of that class inside a new class. We call this �creating a member object.� Your new class can be made up of any number and type of other objects, in any combination that you need to achieve the functionality desired in your new class. Because you are composing a new class from existing classes, this concept is called composition (if the composition happens dynamically, it�s usually called aggregation). Composition is often referred to as a �has-a� relationship, as in �A car has an engine.� 
 (This UML diagram indicates composition with the filled diamond, which states there is one car. I will typically use a simpler form: just a line, without the diamond, to indicate an association.5)  
Composition comes with a great deal of flexibility. The member objects of your new class are typically private, making them inaccessible to the client programmers who are using the class. This allows you to change those members without disturbing existing client code. You can also change the member objects at run time, to dynamically change the behavior of your program. Inheritance, which is described next, does not have this flexibility since the compiler must place compile-time restrictions on classes created with inheritance.  
Because inheritance is so important in object-oriented programming, it is often highly emphasized, and the new programmer can get the idea that inheritance should be used everywhere. This can result in awkward and overly complicated designs. Instead, you should first look to composition when creating new classes, since it is simpler and more flexible. If you take this approach, your designs will be cleaner. Once you�ve had some experience, it will be reasonably obvious when you need inheritance.  Inheritance  
By itself, the idea of an object is a convenient tool. It allows you to package data and functionality together by concept, so you can represent an appropriate problem-space idea rather than being forced to use the idioms of the underlying machine. These concepts are expressed as fundamental units in the programming language by using the class keyword.  
It seems a pity, however, to go to all the trouble to create a class and then be forced to create a brand new one that might have similar functionality. It�s nicer if we can take the existing class, clone it, and then make additions and modifications to the clone. This is effectively what you get with inheritance, with the exception that if the original class (called the base class or superclass or parent class) is changed, the modified �clone� (called the derived class or inherited class or subclass or child class) also reflects those changes.  
 
(The arrow in this UML diagram points from the derived class to the base class. As you will see, there is commonly more than one derived class.)  
A type does more than describe the constraints on a set of objects; it also has a relationship with other types. Two types can have characteristics and behaviors in common, but one type may contain more characteristics than another and may also handle more messages (or handle them differently). Inheritance expresses this similarity between types by using the concept of base types and derived types. A base type contains all of the characteristics and behaviors that are shared among the types derived from it. You create a base type to 
5 This is usually enough detail for most diagrams, and you don�t need to get specific about whether you�re using aggregation or composition.  
represent the core of your ideas about some objects in your system. From the base type, you derive other types to express the different ways that this core can be realized.  
For example, a trash-recycling machine sorts pieces of trash. The base type is �trash�, and each piece of trash has a weight, a value, and so on, and can be shredded, melted, or decomposed. From this, more specific types of trash are derived that may have additional characteristics (a bottle has a color) or behaviors (an aluminum can may be crushed, a steel can is magnetic). In addition, some behaviors may be different (the value of paper depends on its type and condition). Using inheritance, you can build a type hierarchy that expresses the problem you�re trying to solve in terms of its types.  
A second example is the classic �shape� example, perhaps used in a computer-aided design system or game simulation. The base type is �shape,� and each shape has a size, a color, a position, and so on. Each shape can be drawn, erased, moved, colored, etc. From this, specific types of shapes are derived (inherited)�circle, square, triangle, and so on�each of which may have additional characteristics and behaviors. Certain shapes can be flipped, for example. Some behaviors may be different, such as when you want to calculate the area of a shape. The type hierarchy embodies both the similarities and differences between the shapes.  
 
Casting the solution in the same terms as the problem is very useful because you don�t need a lot of intermediate models to get from a description of the problem to a description of the solution. With objects, the type hierarchy is the primary model, so you go directly from the description of the system in the real world to the description of the system in code. Indeed, one of the difficulties people have with object-oriented design is that it�s too simple to get from the beginning to the end. A mind trained to look for complex solutions can initially be stumped by this simplicity.  
When you inherit from an existing type, you create a new type. This new type contains not only all the members of the existing type (although the private ones are hidden away and inaccessible), but more importantly it duplicates the interface of the base class. That is, all the messages you can send to objects of the base class you can also send to objects of the derived class. Since we know the type of a class by the messages we can send to it, this means that the derived class is the same type as the base class. In the previous example, �A circle is a shape.� This type equivalence via inheritance is one of the fundamental gateways in understanding the meaning of object-oriented programming.  
Since both the base class and derived class have the same fundamental interface, there must be some implementation to go along with that interface. That is, there must be some code to execute when an object receives a particular message. If you simply inherit a class and don�t 
22 Thinking in Java Bruce Eckel 
do anything else, the methods from the base-class interface come right along into the derived class. That means objects of the derived class have not only the same type, they also have the same behavior, which isn�t particularly interesting.  
You have two ways to differentiate your new derived class from the original base class. The first is quite straightforward: You simply add brand new methods to the derived class. These new methods are not part of the base-class interface. This means that the base class simply didn�t do as much as you wanted it to, so you added more methods. This simple and primitive use for inheritance is, at times, the perfect solution to your problem. However, you should look closely for the possibility that your base class might also need these additional methods. This process of discovery and iteration of your design happens regularly in object-oriented programming.  
 
Although inheritance may sometimes imply (especially in Java, where the keyword for inheritance is extends) that you are going to add new methods to the interface, that�s not necessarily true. The second and more important way to differentiate your new class is to change the behavior of an existing base-class method. This is referred to as overriding that method.  
Introduction to Objects 23�

 
To override a method, you simply create a new definition for the method in the derived class. You�re saying, �I�m using the same interface method here, but I want it to do something different for my new type